////////////////////////////////////////////////////////////////////////////////
//! \addtogroup ddi_media_nand_hal_internals
//! @{
//!
//  Copyright (c) 2005 SigmaTel, Inc.
//!
//! \file    ddi_nand_hal_common.cpp
//! \brief   NAND HAL common functions for the NAND.
//!
//! This file contains the NAND HAL common functions.
//!
////////////////////////////////////////////////////////////////////////////////

#include "types.h"
#include "ddi_nand_hal_internal.h"
#include "drivers/media/nand/include/ddi_nand.h"

///////////////////////////////////////////////////////////////////////////////
// Code
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// See ddi_nand_hal.h for documentation.
///////////////////////////////////////////////////////////////////////////////
unsigned NandHal::getChipSelectCount()
{
    return g_nandHalContext.chipSelectCount;
}

///////////////////////////////////////////////////////////////////////////////
// See ddi_nand_hal.h for documentation.
///////////////////////////////////////////////////////////////////////////////
NandParameters_t & NandHal::getParameters()
{
    return g_nandHalContext.parameters;
}

///////////////////////////////////////////////////////////////////////////////
// See ddi_nand_hal.h for documentation.
///////////////////////////////////////////////////////////////////////////////
NandPhysicalMedia * NandHal::getNand(unsigned chipSelect)
{
    assert(chipSelect < MAX_NAND_DEVICES);
    return g_nandHalContext.nands[chipSelect];
}

///////////////////////////////////////////////////////////////////////////////
// See ddi_nand_hal.h for documentation.
///////////////////////////////////////////////////////////////////////////////
unsigned NandHal::getChipSelectForAbsoluteBlock(uint32_t block)
{
    unsigned chipSelect;
    
    for (chipSelect = 0; chipSelect < g_nandHalContext.chipSelectCount; ++chipSelect)
    {
        NandPhysicalMedia * nand = g_nandHalContext.nands[chipSelect];
        if (block < nand->wTotalBlocks)
        {
            return chipSelect;
        }
        
        // Subtract off this chip's blocks.
        block -= nand->wTotalBlocks;
    }
    
    // The block was out of range.
    assert(0);
    return 0;
}

///////////////////////////////////////////////////////////////////////////////
// See ddi_nand_hal.h for documentation.
///////////////////////////////////////////////////////////////////////////////
unsigned NandHal::getChipSelectForAbsolutePage(uint32_t page)
{
    uint32_t block = g_nandHalContext.nands[0]->pageToBlock(page);
    return getChipSelectForAbsoluteBlock(block);
}

///////////////////////////////////////////////////////////////////////////////
// See ddi_nand_hal.h for documentation.
///////////////////////////////////////////////////////////////////////////////
NandPhysicalMedia * NandHal::getNandForAbsoluteBlock(uint32_t block)
{
    return getNand(getChipSelectForAbsoluteBlock(block));
}

///////////////////////////////////////////////////////////////////////////////
// See ddi_nand_hal.h for documentation.
///////////////////////////////////////////////////////////////////////////////
NandPhysicalMedia * NandHal::getNandForAbsolutePage(uint32_t page)
{
    return getNand(getChipSelectForAbsolutePage(page));
}

///////////////////////////////////////////////////////////////////////////////
// See ddi_nand_hal.h for documentation.
///////////////////////////////////////////////////////////////////////////////
uint32_t NandHal::getTotalBlockCount()
{
    return g_nandHalContext.totalBlockCount;
}

///////////////////////////////////////////////////////////////////////////////
// See ddi_nand_hal.h for documentation.
///////////////////////////////////////////////////////////////////////////////
bool NandHal::isAbsoluteBlockValid(uint32_t block)
{
    unsigned chipSelect;
    
    for (chipSelect = 0; chipSelect < g_nandHalContext.chipSelectCount; ++chipSelect)
    {
        NandPhysicalMedia * nand = g_nandHalContext.nands[chipSelect];
        if (block < nand->wTotalBlocks)
        {
            return true;
        }
        
        // Subtract off this chip's blocks.
        block -= nand->wTotalBlocks;
    }
    
    // The block was out of range.
    return false;
}

///////////////////////////////////////////////////////////////////////////////
// See ddi_nand_hal.h for documentation.
///////////////////////////////////////////////////////////////////////////////
bool NandHal::isAbsolutePageValid(uint32_t page)
{
    uint32_t block = g_nandHalContext.nands[0]->pageToBlock(page);
    return isAbsoluteBlockValid(block);
}

///////////////////////////////////////////////////////////////////////////////
// End of file
///////////////////////////////////////////////////////////////////////////////
//! @}
